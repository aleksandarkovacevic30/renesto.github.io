<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="robots" content="noindex, nofollow">
  <meta name="googlebot" content="noindex, nofollow">

<!--    <link rel="stylesheet" type="text/css" href="/css/result-light.css">-->
      <script type="text/javascript" src="jquery-latest.min.js"></script>
      <script type="text/javascript" src="bootstrap.min.js"></script>
      <link rel="stylesheet" type="text/css" href="bootstrap.min.css">
      <script type="text/javascript" src="jquery.mark.min.js"></script>
  <style type="text/css">
    h1 {
        counter-reset: h2counter;
    }
    h2:before {
        content: counter(h2counter) ".\0000a0\0000a0";
        counter-increment: h2counter;
        counter-reset: h3counter;
    }
    h3:before {
        content: counter(h2counter) "." counter(h3counter) ".\0000a0\0000a0";
        counter-increment: h3counter;
    }

    body {
  margin: 15px;
        counter-reset: h2counter;

}

div.search span,
div.search input[name="regex"] {
  display: block;
}

div.search input[name="regex"],
button {
  margin-top: 4px;
}

div.panel {
  margin-bottom: 15px;
}

div.panel .panel-body p:last-child {
  margin-bottom: 0;
}

mark {
  padding: 0;
}

  </style>

  <title>Reguläre Ausdrücke - Eine Schulung für Fachanwender</title>


<script type='text/javascript'>//<![CDATA[
window.onload=function(){
$(function() {

  var mark = function() {

    // Read input
    var inputstring = $("input[name='regex']").val();
    if (inputstring.trim() === "") {
      return;
    }

    // Create regex
    var flags = "gim";//inputstring.replace(/.*\/([gimy]*)$/, '$1');
//    var pattern = inputstring.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');
    var pattern = inputstring;//.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');

    var regex = new RegExp(pattern, flags);

    // Determine selected options
    var options = {};
    $("input[name='opt[]']").each(function() {
      options[$(this).val()] = $(this).is(":checked");
    });

    // Mark the regex inside the context
    $(".context").unmark({
      done: function() {
        $(".context").markRegExp(regex, options);
      }
    });
  };


  // Trigger mark action on button click
  $("button[name='mark']").on("click", mark);

});

}//]]> 

</script>

  
</head>

<body>
  <div class="document">
  <h1>Reguläre Ausdrücke - Eine Schulung für Fachanwender</h1>

<h2>Ziel der Schulung</h2>

<div class="content">
In dieser Schulung soll das Konzept der regulären Ausdrücke insbesondere für Fachanwender erläutert werden.</br>
Zu Beginn einfache Beispielübungen sollen diese Anwender zur Nutzung diese mächtigen Werkzeuges befähigen.</br>
Technische Vorkenntnisse werden nicht vorausgesetzt, jedoch sind Grundkenntnisse in Office hilfreich.</br>
</div>
<h2> Was sind reguläre Ausdrücke?</h2>

<div class="content">
Der Begriff „regulärer Ausdruck“ kommt aus der Informatik. Diese dient im wesentlichen zur Beschreibung von Zeichenketten in einem eher theoretischen Zusammenhang („reguläre Sprachen“).</br>
Unabhängig davon kann dieses Konzept für ein sehr mächtiges und zielgerichtetes „Suchen und Ersetzen“ verwendet werden. Unter anderem bieten Excel und notepad++ diese Funktionalität.</br>
</div>

<h2>Schulungsumgebung</h2>

<div class="content">
Für die Schulung beabsichtigen wir ein sogenanntes Notebook zur Verfügung zu stellen, in dem die regulären Ausdrücke erprobt werden können und die Lösung von Übungsaufgaben selbstverantwortlich kontrolliert werden kann.</br>
Bislang ist nicht klar, auf welcher Plattform dies durchgeführt werden soll. Hier bieten sich google cloud services, microsoft azure oder eine lokale installation an. Inwieweit cloudera hier angemessen wäre ist zu klären.</br>
</div>

<h2>Schulungskonzeption</h2>

<h3>Schulungskonzeption</h3>

<div class="content">
Beschreibung der Schulungsumgebung und Vorgehensweise (noch offen, tbd).</br>
</div>

<h3>Lektion 1: Zeichen, Zahlen und Sonderzeichen</h3>

<div class="content">
Wenn wir in der Praxis von Textdarstellungen sprechen, so geht es im wesentlichen um drei immer um drei Gruppen:</br>
<ol>
<li>Zeichen (a,b,c, … , z,A,B,C, … ,Z)</li>
<li>Zahlen (0,1,2, … 9)</li>
<li>Sonderzeichen (jedes „Textstückchen“, das nicht bereits schon oben dargestellt ist, z.B. !“§%& usw.)</li>
</ol>
Meistens wird hier der sog. ASCII Code verwendet, siehe hierzu <a href="https://de.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange">ASCII Tabellen</a> im Netz.
Für die Übung stellen wir uns nun einen „Automaten“ vor, der für gegebene Zeichenketten Teilstrings findet. Wie er das tut, ist in diesem Schritt egal.
</div>

<h3>Übung 1: Zeichen, Zahlen und Sonderzeichen</h3>

<h4> Übung 1a: Zeichen</h4>
Im Beispiel sind folgende Zeichenketten (hier BICs) gegeben:
<div class="test">
<pre>
COBADEFFXXX
DEUTDEFFXXX
COBADEFFXXX
</pre>
</div>

<ol type="a">
  <li>Definiere Teilzeichenkette, die die Commerzbank BICs herausfiltern. </li>
<li>Welches Zeichen charakterisiert Commerzbank BICs im Beispiel minimal (Achtung: Die Lösung ist nicht eindeutig).</li>
<li>Der Dezimale Ascii Code 40 stellt die linksoffene Klammer dar und kann mit der Tastenkombination Alt – 40 (Ziffernpad) abgerufen werden. Wie lautet der Ascii Code für das Zeichen „@“ ?</li>
</ol>

<h4>Übung 1b: Ziffern</h4>

In einem Kommentarfeld werden Nachrichtentypen wie
<div class="test">
  <pre>
103 from 12.03.2016
MT103 dated Nov. 2016
MT202 blabla
Your 202
Your MT202Cov
</pre>
</div>
<ol type="a">
  <li>Definiere Teilzeichenkette, die nur aus Ziffern besteht und nur Text anzeigt, der sich auf den Nachrichtentyp MT103 bezieht.</li>
  <li>Ist es möglich nur mit Ziffern alle Texte zu finden, die sich auf MT202xxx Transaktionen beziehen?</li>
</ol>

<h4>Übung 1c: Sonderzeichen</h4>
<div class="content">
Sonderzeichen sind ein spezielles Thema. So bezeichnet der Punkt „.“ etwa eine Joker (wildcard) für ein beliebiges Zeichen (warum so etwas überhaupt Sinn macht erklären wir später). Für ein Sonderzeichen (also z.B. den Punkt) benötigt man eine spezielle Kennzeichnung, man muss dem Automat sagen dass jetzt das Zeichen Punkt kommt und nicht der wildcard. Dazu verwendet man den backslash: „ \.“. 
Betrachte folgende Beispiele:
</div>
<div class="test">
  <pre>
123.00 EUR
123.24 USD
MT103
</pre>
</div>

<div class="content">
  <ol type="a">
    <li>Finde über ein Sonderzeichen alle Textketten, die wie ein Betrag aussehen.</li>
<li>Was würde passieren, wenn wir die obige Beispielliste um 100 SGD erweitern und dann die Abfrage unter a) erneut durchführen?</li>
</ol>
</div>

<h3>Lektion 2: Ein Zeichen einschließen oder ausschließen</h3>

<div class="content">
In dieser Lektion betrachten wir das einschließen oder ausschließen eines einzelnen Zeichens bei der Suche in einem Text.
Die Syntax hierfür ist nicht besonders schwer:
<ol>
  <li>[abc] bezeichnet ein Zeichen, das a, b oder c ist</li>
<li>[^abc] bezeichnet ein Zeichen, das nicht a, b oder c ist.</li>
</ol>
Mit diesem Baustein kann man nun differenziert Texte auswählen, wie wir in der nachfolgenden Übung sehen werden. 
Manchmal ist es sinnvoll ganze Bereiche zu Kennzeichnen:
<ol>
  <li>[a-z] bezeichnet ein Zeichen „zwischen“ a und z</li>
  <li>[0-9] bezeichnet eine Zahl „zwischen“ 0 und 9.</li>
</ol>

Dies wollen wir in nachfolgender Übung vertiefen.
</div>

<h3>Übung 2: Ein Zeichen einschließen oder ausschließen</h3>
<div class="content">
In dieser Übung betrachten wir die folgende Sammlung von IBANs und Kontonummern:
</div>
<div class="test">
<pre>
DE27100777770209299700 
DE11520513735120710131 
AT411100000237571500
AL90208110080000001039531801
BE68844010370034
DK5750510001322617
EE342200221034126658
400 654657
8051465
78988798654
</pre>
</div>

<div class="content">
  <ol type="a">
<li>Finde alle IBANs, die mit D beginnen (Tipp:verwende hierfür die [ ] - Syntax).</li>
<li>Finde alle IBANs, die nicht mit D beginnen.</li>
<li>Finde alle IBANs, die mit DE beginnen (Tip: wende die [ ] – Syntax zweimal an).</li>
<li>Finde alle IBANs im Text (Tip: Bereich)</li>
<li>Finde alle Kontonummern (Tip: Den Anfang einer Zeile kennzeichnet man mit ^).</li>
</ol>
</div>

<h3>Lektion 3: Wiederholungsfaktoren</h3>
<div class="content">
Mittlerweile wissen wir schon, wie man durch Wiederholung (DE) Ausdrücke erkennen kann. Da man nicht alles Tippen will gibt es Wiederholungsfaktoren:
<ol>
<li>{n}  muss n-mal vorkommen</li>
<li>{min,} muss mindestens min mal vorkommen</li>
<li>{0,max} darf höchstens max mal vorkommen</li>
<li>{min,max} kommt mindestens min mal und höchstens max mal vor</li>
</ol>

Einige Fälle werden mit eigenen Symbolen versehen (?, * oder +):

<ol>
<li>{0,} oder * kommt beliebig oft vor</li>
<li>{1,} oder + kommt mindestens einmal vor</li>
<li>{0,1}  oder ? ist optional, kommt 1 mal oder gar nicht vor.</li>
</ol>

Z.B. Ergibt [a]+ Treffer die Zeichenfolgen: a oder aa oder aaa , usw.</br>
Achtung: a*  trifft immer irgendwas, denn jede Zeichenfolge enthält 0 mal das Zeichen a.</br>

Diese Wiederholungsfaktoren sind gierig (greedy), dass heißt, sie versuchen möglichst treffen. Dies kann man sehr schön an einem Beispiel sehen:</br>
Beispiel: Schauen wir uns den Text ABCDEB an. Dann trifft der reguläre Ausdruck A.*B nicht nur AB sondern findet ABCDEB.</br>
Tatsächlich kann man diese Suche auch lazy schalten. Dies wird durch ein nachgestelltes Fragezeichen erreicht.</br>
Beispiel: Schauen wir uns den Text ABCDEB an. Dann trifft der reguläre Ausdruck A.*?B tatsächlich AB.</br>
In den nachfolgenden Übungen versuchen wir nun das Verständnis für Wiederholungsfaktoren zu schärfen.</br>
</div>

<h3>Übung 3: Wiederholungsfaktoren</h3>
<div class="content">
Wir verwenden wieder das Beispiel aus Übung 4.5.

<ol type="a">
<li>Finde alle IBANS, die mit einem A beginnen, dann einen beliebigen Buchstaben haben gefolgt von einer beliebigen Folge von Ziffern.</li>
<li>Wie a) jedoch mit 01 am Ende.</li>
</ol>
</div>

<h3>Lektion 4: Leerzeichen und andere Hürden</h3>
<div class="content">
Als Ergänzung zu obigen Lektionen sei hier noch erwähnt, dass mit \d eine Ziffer bezeichnet wird und mit \D eine Nicht – Ziffer. Analog bezeichnet \w ein alphanumerisches (Ziffern und Zeichen!) und \W ein nicht alphanumerisches Zeichen.</br>
Oftmals benötigt man das mit \s bezeichnete Leerzeichen (whitespace charakter) und als Gegenstück  \S das Nicht – Leerzeichen.</br>
Anwendungsmöglichkeiten werden wir in der nachfolgenden Übung aufzeigen.</br>
Eine fortgeschrittene Ergänzung hierzu ist das Erkennen von Tabulatoren (\t) Zeilenumbrüchen (\r).</br>
</div>
<h3>Übung 4: Leerzeichen und andere Hürden</h3>
<div class="content">
Betrachte den folgenden Beispielsatz:
</div>
<div class="test">
  <pre>
DE27 1007 7777 0209 2997 00 
DE11520513735120710131
AT411100000237571500
AL90208110080000001039531801
BE68844010370034
DK5750510001322617
EE342200221034126658
400 654657
8051465
78 9887986 54
</pre>
</div>
<div class="content">
<ol type="a">
<li>Erkenne die deutschen IBANs mit einem regulären Ausdruck, der die verschiedenen obigen Schreibweisen umfasst (Tip: Verwende \d und \s)</li>
<li>Erkenne Kontonummern, die an beliebigen Stellen (außer am Anfang) Leerzeichen enthalten können.</li>
</ol>
</div>

<h3>Lektion 5: Der Beginn und der Anfang</h3>
<div class="content">
Bislang haben wir zumeist nach Vorkommen irgendwo im String geschaut. Um jedoch das zu treffen, was man will, ist es oftmals erforderlich, den regulären Ausdruck möglichst genau auf den Suchbegriff zu fokussieren. Hierbei sind die sogenannten Begrenzer:
<ol>
<li>Anfangsmarke : ˆ (Hut) und</li>
<li>Endmarke   : $ (Dollar Zeichen)</li>
</ol>
hilfreich.</br>

Hierbei ist zu beachten, dass diese Zeichen kontextsensitiv („von der Umgebung abhängend“) sind. Vgl. hierzu die Bedeutung von [^abc].
Um dies etwas klarer zu machen, geben wir folgendes Beispiel aus einem Logfile:
</div>
<div class="test">
<pre>
error Accessing Customer Data unsuccesfull!
success Operation Completed.
</pre>
</div>
<div class="content">
Wenn wir nun die erfolgreichen Durchführungen filtern wollen, so würde die Suche nach dem Wort success sowohl den ersten als auch den zweiten Text treffen. Die Suche nach ^success wäre allerdings dann wieder eindeutig.
</div>

<h3>Übung 5: Der Beginn und der Anfang</h3>
<div class="content">
Betrachte folgende BIC – Liste:
</div>
<div class="test">
  <pre>
AUSKDEFFXXX
BCITUS33XXX
BGUSBGSFXXX
BKTRUS33XXX
BMUSOMRXXXX
BNPAUS3NXXX
BOFAAUSXXXX BGUSBGSFXXX
BOFAUS3NXXX
BOFAUS6NGFX
BOFAUS6SSFX BRUSDE66XXX
BOFAUS6SXXX
BOTKUS33XXX
BOTKUS6LXXX
BRUSDE66XXX
BWSTUS66XXX
CBKCUS44XXX
CHASUS33FXR
CHASUS33XXX
CITIUS33XXX 
COBAUS3XXXX
DUSSDEDDXXX
FLBKUS33XXX
FNBPUS33XXX
FRSTUS44XXX
FTBCUS3CXXX
GOLDUS33XXX
HANYUS33XXX
/DE12365478965412365412321 HATRUS44XXX
/81651666 IRVTUS3NXXX
KEYBUS33FEX 
</pre>
</div>

<div class="content">
  <ol type="a">
<li>Finde alle BICs, die am Anfang einer Zeile stehen und sich auf ein US – Institut beziehen, also an der Stelle 5 und 6 US enthalten.</li>
<li>Finde alle BICs, die am Ende einer Zeile stehen und sich auf ein US – Institut beziehen</li>
<li>Was ist der Unterschied in den Ergebnissen a und b?</li>
</ol>
</div>

<h3>Übung 5: Das Konzept der Gruppierung</h3>

<div class="content">
Sogenannte Gruppierungen ermöglichen es insbesondere, Teildaten für eine weitere Verarbeitung auszuschneiden. Diese Gruppen werden durch Klammern gebildet. </br>
Das folgende Beispiel zeigt die Möglichkeiten für eine BIC6. Nehmen wir die BIC6 COBADE. Diese können wir mit dem regulären Ausdruck ^(.{4})(.{2})$ in zwei Gruppen zerlegt werden die erste enthält dann COBA und die zweite Gruppe enthält DE.</br>
</br>
Diese Gruppen können auch verschachtelt auftreten (Klammer in Klammer). Im Beispiel ergibt der beispielhafte Ausdruck ^(.{4}(.{2}))$ als „äußere Gruppe“ COBADE und als „innere Gruppe“ DE.</br>
Eine Erweiterung ergibt sich, wenn man bedingte Gruppierung zulässt. Bedingungen werden in Klammern durch das „pipe“ Symbol dargestellt. Im vorhergehenden Beispiel könnte man mit ^(.{4}(DE|IT))$ zwar im gegebenen Einzelfall das vorhergehende Ergebnis erzeugen würde aber z.B. CITIUS ignorieren.</br>
Es ist weiterhin möglich diese Ausdrücke zu referenzieren. Im Beispiel oben^\1(.{4})\1(.{2})$. Mit diesem Instrument können wir Ersetzen – Operationen durchführen. Dies ist allerdings Sprachabhängig.
</div>


=====================

<div class="panel panel-default">
  <div class="panel-heading">Search</div>
  <div class="panel-body">
    <div class="search row">
      <div class="col-xs-6">
        <span>Type in a regular expression:</span>
        <input type="text" name="regex" class="form-control input-sm" placeholder="/Lor[^]?m/gmi">
        <button type="button" name="mark" class="btn btn-primary">Mark</button>
      </div>
    </div>
  </div>
</div>


<div class="panel panel-default">
  <div class="panel-body context">
    <p>
      Lorem ipsum dolor sit āmet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, nò sea takimata
      sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea
      rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.
      At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie çonsequat, vel illum dolore
      eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit prāesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet,
    </p>

  </div>
</div>
</div>
</body>

</html>

